## Vuln Links
### Security Bulletin
https://chromereleases.googleblog.com/2023/04/stable-channel-update-for-desktop_14.html
### Chromium Git Release
https://chromium.googlesource.com/chromium/src/+/refs/tags/112.0.5615.137
### Chromium Git Release Log
https://chromium.googlesource.com/chromium/src/+log/refs/tags/112.0.5615.137
### V8 Git Release Log
https://chromium.googlesource.com/v8/v8.git/+log/6538a20aa097f9c05ead98eb88c71819aa1e65aa

## Exploitation Links
### Javascript Engine Exploitation
https://saelo.github.io/papers/thesis.pdf

### V8 and Chrome Exploitation
https://jhalon.github.io/chrome-browser-exploitation-1/

### Learning V8
https://github.com/danbev/learning-v8

### V8 Object Representation
https://jayconrod.com/posts/52/a-tour-of-v8-object-representation

### V8 Exploitation
https://sensepost.com/blog/2020/intro-to-chromes-v8-from-an-exploit-development-angle/


# The Patches
Patch code and notes

# Quick Fix
https://chromium-review.googlesource.com/c/v8/v8/+/4417690?tab=comments
https://chromium.googlesource.com/v8/v8/+/fa81078cca6964def7a3833704e0dba7b05065d8%5E%21/


```
diff --git a/src/builtins/builtins-error.cc b/src/builtins/builtins-error.cc
index 01e0162..14c0602 100644
--- a/src/builtins/builtins-error.cc
+++ b/src/builtins/builtins-error.cc
@@ -35,6 +35,9 @@
     THROW_NEW_ERROR_RETURN_FAILURE(
         isolate, NewTypeError(MessageTemplate::kInvalidArgument, object_obj));
   }
+  if (object_obj->IsJSGlobalProxy()) {
+    return ReadOnlyRoots(isolate).undefined_value();
+  }
 
   Handle<JSObject> object = Handle<JSObject>::cast(object_obj);
   Handle<Object> caller = args.atOrUndefined(isolate, 2);
   ```

## Full Fix
https://chromium.googlesource.com/v8/v8/+/79cdd69a1cfa9d3b4d9b6dec7203db4dabe618b4%5E%21/#F5

### Patch Notes

[error] Define Error.stack property as a JavaScript accessor

... instead of the native data property.
This fixes the JS spec violation when reading a data property does not
expect any observable side effects. For example, OrdinaryGetOwnProperty
(see https://tc39.es/ecma262/#sec-ordinarygetownproperty, step 4a).

Differences to previous behaviour:
- Error.stack is defined as a JavaScript accessor property.
- all Error objects get a private "error_stack_symbol" field where
  the captured stack trace is stored (previously it was added only when
  the error was actually thrown which caused unnecessary transitions).
- Error.captureStackTrace(obj) adds public "stack" accessor property
  and private "error_stack_symbol" property to given "obj".
- calling "stack" getter/setter is a no-op in case receiver is not an
  "Error-like" object, i.e. it doesn't have a "error_stack_symbol"
  property and it doesn't have a prototype with such a property (the
  lookup stops at JSProxy or interceptor).
- the "stack" getter walks the prototype chain from receiver until it
  finds a holder with the "error_stack_symbol" property which is then
  used for computing the result.
  This is slightly different from the previous behaviour in case
  receiver's prototype chain contains multiple error objects.
- the "stack" setter walks the prototype chain from receiver until it
  finds a holder with the "error_stack_symbol" property and stores the
  value there.

Drive-by: handle lazy accessor pairs in ObjectVisitorDeepFreezer.

### My Thoughts
Figure out the JSGlobalProxy vs. JSObject

src/codegen/code-stub-assembler.cc:TNode<BoolT> CodeStubAssembler::IsJSGlobalProxy(TNode<HeapObject> object) {

# The bug
Let's assume that JSGlobalProxy is the culprit since the first patch specifically targets that.
## Suspectible Code
```
BUILTIN(ErrorCaptureStackTrace) {
  HandleScope scope(isolate);
  Handle<Object> object_obj = args.atOrUndefined(isolate, 1);
  isolate->CountUsage(v8::Isolate::kErrorCaptureStackTrace);
  if (!object_obj->IsJSObject()) {
    THROW_NEW_ERROR_RETURN_FAILURE(
        isolate, NewTypeError(MessageTemplate::kInvalidArgument, object_obj));
  }
  Handle<JSObject> object = Handle<JSObject>::cast(object_obj);
  Handle<Object> caller = args.atOrUndefined(isolate, 2);
  FrameSkipMode mode = caller->IsJSFunction() ? SKIP_UNTIL_SEEN : SKIP_FIRST;
  // Collect the stack trace.
  RETURN_FAILURE_ON_EXCEPTION(
      isolate, isolate->CaptureAndSetErrorStack(object, mode, caller));
  // Add the stack accessors.
  Handle<AccessorInfo> error_stack = isolate->factory()->error_stack_accessor();
  Handle<Name> name(Name::cast(error_stack->name()), isolate);
  // Explicitly check for frozen objects. Other access checks are performed by
  // the LookupIterator in SetAccessor below.
  if (!JSObject::IsExtensible(isolate, object)) {
    return isolate->Throw(*isolate->factory()->NewTypeError(
        MessageTemplate::kDefineDisallowed, name));
  }
  RETURN_FAILURE_ON_EXCEPTION(
      isolate, JSObject::SetAccessor(object, name, error_stack, DONT_ENUM));
  return ReadOnlyRoots(isolate).undefined_value();
}
```

## JSGlobalProxy Object in v8
"Global proxy object is a thin wrapper whose prototype points to
- * actual context's global object with the properties like Object, etc.
- * This is done that way for security reasons (for more details see
+ * Global proxy object is a thin wrapper whose prototype points to actual
+ * context's global object with the properties like Object, etc. This is
done
+ * that way for security reasons (for more details see
* https://wiki.mozilla.org/Gecko:SplitWindow)." - 
https://groups.google.com/g/v8-dev/c/LGKA061oG5I

https://groups.google.com/a/chromium.org/g/blink-reviews-bindings/c/ldELuqF1ews



## Type Confusion?
Is there a JSGlobalProxy type object_obj that will pass the IsJSObject check, resulting in a cast to JSObject?
```
HandleScope scope(isolate);
  Handle<Object> object_obj = args.atOrUndefined(isolate, 1);
  isolate->CountUsage(v8::Isolate::kErrorCaptureStackTrace);
  if (!object_obj->IsJSObject()) {
    THROW_NEW_ERROR_RETURN_FAILURE(
        isolate, NewTypeError(MessageTemplate::kInvalidArgument, object_obj));
  }
  Handle<JSObject> object = Handle<JSObject>::cast(object_obj); 
```
