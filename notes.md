## Vuln Links
### Security Bulletin
https://chromereleases.googleblog.com/2023/04/stable-channel-update-for-desktop_14.html
### Chromium Git Release
https://chromium.googlesource.com/chromium/src/+/refs/tags/112.0.5615.137
### Chromium Git Release Log
https://chromium.googlesource.com/chromium/src/+log/refs/tags/112.0.5615.137
### V8 Git Release Log
https://chromium.googlesource.com/v8/v8.git/+log/6538a20aa097f9c05ead98eb88c71819aa1e65aa

## Exploitation Links
### Javascript Engine Exploitation
https://saelo.github.io/papers/thesis.pdf
http://www.phrack.org/issues/70/3.html

### V8 and Chrome Exploitation
https://jhalon.github.io/chrome-browser-exploitation-1/

### Learning V8
https://github.com/danbev/learning-v8

### V8 Object Representation
https://jayconrod.com/posts/52/a-tour-of-v8-object-representation

### V8 Exploitation
https://sensepost.com/blog/2020/intro-to-chromes-v8-from-an-exploit-development-angle/


# The Patches
Patch code and notes

# Quick Fix
https://chromium-review.googlesource.com/c/v8/v8/+/4417690?tab=comments
https://chromium.googlesource.com/v8/v8/+/fa81078cca6964def7a3833704e0dba7b05065d8%5E%21/


```
diff --git a/src/builtins/builtins-error.cc b/src/builtins/builtins-error.cc
index 01e0162..14c0602 100644
--- a/src/builtins/builtins-error.cc
+++ b/src/builtins/builtins-error.cc
@@ -35,6 +35,9 @@
     THROW_NEW_ERROR_RETURN_FAILURE(
         isolate, NewTypeError(MessageTemplate::kInvalidArgument, object_obj));
   }
+  if (object_obj->IsJSGlobalProxy()) {
+    return ReadOnlyRoots(isolate).undefined_value();
+  }
 
   Handle<JSObject> object = Handle<JSObject>::cast(object_obj);
   Handle<Object> caller = args.atOrUndefined(isolate, 2);
   ```

## Full Fix
https://chromium.googlesource.com/v8/v8/+/79cdd69a1cfa9d3b4d9b6dec7203db4dabe618b4%5E%21/#F5

### Patch Notes

[error] Define Error.stack property as a JavaScript accessor

... instead of the native data property.
This fixes the JS spec violation when reading a data property does not
expect any observable side effects. For example, OrdinaryGetOwnProperty
(see https://tc39.es/ecma262/#sec-ordinarygetownproperty, step 4a).

Differences to previous behaviour:
- Error.stack is defined as a JavaScript accessor property.
- all Error objects get a private "error_stack_symbol" field where
  the captured stack trace is stored (previously it was added only when
  the error was actually thrown which caused unnecessary transitions).
- Error.captureStackTrace(obj) adds public "stack" accessor property
  and private "error_stack_symbol" property to given "obj".
- calling "stack" getter/setter is a no-op in case receiver is not an
  "Error-like" object, i.e. it doesn't have a "error_stack_symbol"
  property and it doesn't have a prototype with such a property (the
  lookup stops at JSProxy or interceptor).
- the "stack" getter walks the prototype chain from receiver until it
  finds a holder with the "error_stack_symbol" property which is then
  used for computing the result.
  This is slightly different from the previous behaviour in case
  receiver's prototype chain contains multiple error objects.
- the "stack" setter walks the prototype chain from receiver until it
  finds a holder with the "error_stack_symbol" property and stores the
  value there.

Drive-by: handle lazy accessor pairs in ObjectVisitorDeepFreezer.

### My Thoughts
Figure out the JSGlobalProxy vs. JSObject

src/codegen/code-stub-assembler.cc:TNode<BoolT> CodeStubAssembler::IsJSGlobalProxy(TNode<HeapObject> object) {

# The bug
Let's assume that JSGlobalProxy is the culprit since the first patch specifically targets that.
## Suspectible Code
```
BUILTIN(ErrorCaptureStackTrace) {
  HandleScope scope(isolate);
  Handle<Object> object_obj = args.atOrUndefined(isolate, 1);
  isolate->CountUsage(v8::Isolate::kErrorCaptureStackTrace);
  if (!object_obj->IsJSObject()) {
    THROW_NEW_ERROR_RETURN_FAILURE(
        isolate, NewTypeError(MessageTemplate::kInvalidArgument, object_obj));
  }
  Handle<JSObject> object = Handle<JSObject>::cast(object_obj);
  Handle<Object> caller = args.atOrUndefined(isolate, 2);
  FrameSkipMode mode = caller->IsJSFunction() ? SKIP_UNTIL_SEEN : SKIP_FIRST;
  // Collect the stack trace.
  RETURN_FAILURE_ON_EXCEPTION(
      isolate, isolate->CaptureAndSetErrorStack(object, mode, caller));
  // Add the stack accessors.
  Handle<AccessorInfo> error_stack = isolate->factory()->error_stack_accessor();
  Handle<Name> name(Name::cast(error_stack->name()), isolate);
  // Explicitly check for frozen objects. Other access checks are performed by
  // the LookupIterator in SetAccessor below.
  if (!JSObject::IsExtensible(isolate, object)) {
    return isolate->Throw(*isolate->factory()->NewTypeError(
        MessageTemplate::kDefineDisallowed, name));
  }
  RETURN_FAILURE_ON_EXCEPTION(
      isolate, JSObject::SetAccessor(object, name, error_stack, DONT_ENUM));
  return ReadOnlyRoots(isolate).undefined_value();
}
```

## JSGlobalProxy Object in v8
```
"Global proxy object is a thin wrapper whose prototype points to
- * actual context's global object with the properties like Object, etc.
- * This is done that way for security reasons (for more details see
+ * Global proxy object is a thin wrapper whose prototype points to actual
+ * context's global object with the properties like Object, etc. This is
done
+ * that way for security reasons (for more details see
* https://wiki.mozilla.org/Gecko:SplitWindow)."
```
https://groups.google.com/g/v8-dev/c/LGKA061oG5I

### JSGlobalProxy in src/objects/objects.h
```
//
// Most object types in the V8 JavaScript are described in this file.
//
// Inheritance hierarchy:
// - Object
//   - Smi          (immediate small integer)
//   - TaggedIndex  (properly sign-extended immediate small integer)
//   - HeapObject   (superclass for everything allocated in the heap)
//     - JSReceiver  (suitable for property access)
//       - JSObject
//         - JSArray
//           - TemplateLiteralObject
//         - JSArrayBuffer
//         - JSArrayBufferView
//           - JSTypedArray
//           - JSDataView
//         - JSCollection
//           - JSSet
//           - JSMap
//         - JSCustomElementsObject (may have elements despite empty FixedArray)
//           - JSSpecialObject (requires custom property lookup handling)
//             - JSGlobalObject
//             - JSGlobalProxy
//             - JSModuleNamespace
//           - JSPrimitiveWrapper
//         - JSDate
```

```
// An abstract superclass for JSObjects that require non-standard element
// access. It doesn't carry any functionality but allows function classes to be
// identified in the type system.
class JSSpecialObject
    : public TorqueGeneratedJSSpecialObject<JSSpecialObject,
                                            JSCustomElementsObject> {
 public:
  STATIC_ASSERT(kHeaderSize == JSObject::kHeaderSize);
  TQ_OBJECT_CONSTRUCTORS(JSSpecialObject)
};
```

```
// JSGlobalProxy's prototype must be a JSGlobalObject or null,
// and the prototype is hidden. JSGlobalProxy always delegates
// property accesses to its prototype if the prototype is not null.
//
// A JSGlobalProxy can be reinitialized which will preserve its identity.
//
// Accessing a JSGlobalProxy requires security check.
class JSGlobalProxy
    : public TorqueGeneratedJSGlobalProxy<JSGlobalProxy, JSSpecialObject> {
 public:
  inline bool IsDetachedFrom(JSGlobalObject global) const;
  V8_EXPORT_PRIVATE bool IsDetached() const;
  static int SizeWithEmbedderFields(int embedder_field_count);
  // Dispatched behavior.
  DECL_PRINTER(JSGlobalProxy)
  DECL_VERIFIER(JSGlobalProxy)
  TQ_OBJECT_CONSTRUCTORS(JSGlobalProxy)
};
```

https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/objects.h?q=objects.h&ss=chromium%2Fchromium%2Fsrc:v8%2Fsrc%2F



"The JS global proxy object already points to the {Local,Remote}DOMWindow via internal field." - https://groups.google.com/a/chromium.org/g/blink-reviews-bindings/c/ldELuqF1ews

"A GlobalProxy's prototype should always be a proper JSObject." - https://codereview.chromium.org/18402007/patch/5001/6001

### JSGlobalProxy vs JSGlobalObject
```
JSGlobalProxy represents an iframe, whereas JSGlobalObject is the actual state of a page loaded in an iframe. Hence when you navigate an iframe, the JSGlobalProxy is relinked to a new JSGlobalObject. From JS the JSGlobalObject is hidden behind the JSGlobalProxy and invisible.

As long as the iframe is pointed at the page running specific JS, there's not much difference between a global reference "x" (directly accessing the JSGlobalObject unless it's a lexical binding, let, const) and "this.x" (accessing the global object via the JSGlobalProxy). However, if you now navigate the iframe to a new location; "x" will still point to the old global property, whereas this.x will try to load "x" from the new JSGlobalObject behind the reused JSGlobalProxy.
```
https://groups.google.com/g/v8-dev/c/al83OHu2evc/m/ZXBRqvIGBwAJ

## JSGlobalProxy in WebKit
```
void* JSObjectGetPrivate(JSObjectRef object)
{
    JSObject* jsObject = uncheckedToJS(object);

    const ClassInfo* classInfo = classInfoPrivate(jsObject);
    
    // Get wrapped object if proxied
    if (classInfo->isSubClassOf(JSGlobalProxy::info())) {
        jsObject = static_cast<JSGlobalProxy*>(jsObject)->target();
        classInfo = jsObject->classInfo();
    }

    if (classInfo->isSubClassOf(JSCallbackObject<JSGlobalObject>::info()))
        return static_cast<JSCallbackObject<JSGlobalObject>*>(jsObject)->getPrivate();
    if (classInfo->isSubClassOf(JSCallbackObject<JSNonFinalObject>::info()))
        return static_cast<JSCallbackObject<JSNonFinalObject>*>(jsObject)->getPrivate();
#if JSC_OBJC_API_ENABLED
    if (classInfo->isSubClassOf(JSCallbackObject<JSAPIWrapperObject>::info()))
        return static_cast<JSCallbackObject<JSAPIWrapperObject>*>(jsObject)->getPrivate();
#endif
    
    return nullptr;
}
```
https://github.com/WebKit/WebKit/blob/7a82d30fc628c316d55262d810c6e1becca57529/Source/JavaScriptCore/API/JSObjectRef.cpp#L561
https://chromium.googlesource.com/chromium/src/+/5d5865702469fb03a3343898dfeaec73cfa973e3/third_party/WebKit/Source/bindings/core/v8/WindowProxy.h


## Type Confusion?
Is there a JSGlobalProxy type object_obj that will pass the IsJSObject check, resulting in a cast to JSObject?
```
HandleScope scope(isolate);
  Handle<Object> object_obj = args.atOrUndefined(isolate, 1);
  isolate->CountUsage(v8::Isolate::kErrorCaptureStackTrace);
  if (!object_obj->IsJSObject()) {
    THROW_NEW_ERROR_RETURN_FAILURE(
        isolate, NewTypeError(MessageTemplate::kInvalidArgument, object_obj));
  }
  Handle<JSObject> object = Handle<JSObject>::cast(object_obj); 
```

## Triggering the Bug
### Both of these trigger a breakpoint set inside BUILTIN(ErrorCaptureStackTrace)
```
function MyError() {                                             
  Error.captureStackTrace(this);         
  // Any other initialization goes here.
}
    
try{
        throw new MyError();        
} catch (e) {
        // %DebugPrint(e);
        // print(e.stack);
        // %DebugPrint(e.stack);
}
```

```
function MyError() {                                             
  //Error.captureStackTrace(this);       
  // Any other initialization goes here.
}
    
try{
        throw new Error();          
} catch (e) {
        // %DebugPrint(e);
        print(e.stack);   
        // %DebugPrint(e.stack);
}

```
